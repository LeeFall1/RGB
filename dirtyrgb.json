{"slots":{"0":{"name":"slot1","type":{"events":[],"methods":[]}},"1":{"name":"slot2","type":{"events":[],"methods":[]}},"2":{"name":"slot3","type":{"events":[],"methods":[]}},"3":{"name":"slot4","type":{"events":[],"methods":[]}},"4":{"name":"slot5","type":{"events":[],"methods":[]}},"5":{"name":"slot6","type":{"events":[],"methods":[]}},"6":{"name":"slot7","type":{"events":[],"methods":[]}},"7":{"name":"slot8","type":{"events":[],"methods":[]}},"8":{"name":"slot9","type":{"events":[],"methods":[]}},"9":{"name":"slot10","type":{"events":[],"methods":[]}},"-1":{"name":"unit","type":{"events":[],"methods":[]}},"-2":{"name":"system","type":{"events":[],"methods":[]}},"-3":{"name":"library","type":{"events":[],"methods":[]}}},"handlers":[{"code":"unit.hide()\n\nlights = {slot1, slot2, slot3, slot4, slot5, slot6, slot7, slot8, slot9, slot10}\n\ninterval = 50 --export: interval for colour change in ms\nsteps = 50 --export: steps for colour change (interval/steps = tick interval in ms)\noffset = 10 --export: setep offset between the lights\nbrightness = 500 --export: how bright should the colors be\n\n-- set globals\nrgbTick = {}\nrgbDirection = {}\nrgbColors = {}\nrgbNextColor = {math.random(brightness), math.random(brightness), math.random(brightness)}\nrgbNextOffset = 0\nrgbMasterIndex = 0\n\n-- set defaults for all colors\nfor i=1,#lights do\n    if lights[i] then\n        lights[i].activate()\n        rgbColors[i] = rgbNextColor\n        rgbTick[i] = 0 - i * rgbNextOffset\n        rgbDirection[i] = 1\n        rgbNextOffset = rgbNextOffset + offset\n        if rgbMasterIndex == 0 then\n            rgbMasterIndex = i\n        end\n    end\nend\n\n-- rgb timer is set based on interval and steps\n-- if steps == interval, that means 1 tick every millisecond\nrgbTimer = (interval/steps) / 1000\n\n-- set tick timer based on interval and steps\nunit.setTimer(\"rgb\", rgbTimer)\n","filter":{"args":[],"signature":"start()","slotKey":"-1"},"key":"0"},{"code":"for i=1,#lights do\n    if lights[i] then\n        rgbTick[i] = rgbTick[i] + rgbDirection[i] -- add rgbDirection (1 or -1) to rgbTick\n\n        -- calculate the alpha for this tick\n        local alpha = (rgbTick[i] * rgbTimer * 1000) / interval\n\n        -- if alpha reached 100 revert direction to fade to 0\n        if alpha == 1 then\n            rgbDirection[i] = -1\n        end\n\n        -- if alpha is 0 revert direction to go back to 100\n        -- also pick a new color\n        if alpha == 0 then\n            rgbDirection[i] = 1\n            if i == rgbMasterIndex then\n                rgbNextColor = {math.random(brightness), math.random(brightness), math.random(brightness)}\n            end\n            rgbColors[i] = rgbNextColor\n        end\n\n        -- set colors to alpha mutiplied by rgb\n        r = math.max(math.min(rgbColors[i][1] * alpha, brightness), 0)\n        g = math.max(math.min(rgbColors[i][2] * alpha, brightness), 0)\n        b = math.max(math.min(rgbColors[i][3] * alpha, brightness), 0)\n        lights[i].setRGBColor(r,g,b)\n    end\nend\n","filter":{"args":[{"value":"rgb"}],"signature":"tick(timerId)","slotKey":"-1"},"key":"1"},{"code":"-- turn off the lights\nfor i=1,#lights do\n    if lights[i] then\n        lights[i].deactivate()\n        lights[i].setRGBColor(0,0,0)\n    end\nend","filter":{"args":[],"signature":"stop()","slotKey":"-1"},"key":"2"}],"methods":[],"events":[]}
